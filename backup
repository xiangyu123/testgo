package main

import (
	"flag"
	"fmt"
	"time"

	"github.com/golang/glog"

	"github.com/davecgh/go-spew/spew"
	v1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/util/runtime"
	kubeinformers "k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/tools/clientcmd"
)

var (
	kubeconfig = flag.String("kubeconfig", "/root/.kube/config", "absolute path to the kubeconfig file")
)

func main() {
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		glog.Errorln(err)
	}
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		glog.Errorln(err)
	}

	kubeInformerFactory := kubeinformers.NewSharedInformerFactory(clientset, time.Second*30)
	eventInformer := kubeInformerFactory.Core().V1().Events().Informer()

	stopper := make(chan struct{})
	defer close(stopper)
	defer runtime.HandleCrash()

	eventInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    onHandle,
		DeleteFunc: onHandle,
		// UpdateFunc: func(oldObj, newObj interface{}) {
		// 	fmt.Println("==================")
		// 	fmt.Println("pod changed: ")
		// 	spew.Dump(oldObj)
		// 	spew.Dump(newObj)
		// 	fmt.Println("==================")
		// },
	})

	go eventInformer.Run(stopper)
	if !cache.WaitForCacheSync(stopper, eventInformer.HasSynced) {
		runtime.HandleError(fmt.Errorf("Timed out waiting for caches to sync"))
		return
	}
	<-stopper
}

func onHandle(obj interface{}) {
	if event, ok := obj.(*v1.Event); ok {
		fmt.Println(event.Kind)
		fmt.Println(event.Type)
		fmt.Println(event.Action)
		fmt.Println(event.Source)
		spew.Dump(event)
		// fmt.Println(pod.Namespace)
		// fmt.Println(pod.Name)
		// fmt.Println(pod.Status.Phase)
		// readyCount := 0
		// podCount := len(pod.Status.ContainerStatuses)
		// for _, v := range pod.Status.ContainerStatuses {
		// 	if v.Ready {
		// 		readyCount += 1
		// 	}
		// }

		// if readyCount == podCount {
		// 	fmt.Println("after_pod: ", pod.Name, "ready")
		// 	fmt.Println("after_pod: ", pod.Status.PodIP, "ip")
		// 	fmt.Println("after_pod: ", pod.Status.Reason, "reason")
		// 	fmt.Println("after_pod: ", pod.Status.Message, "message")
		// }
	}
}

// pods, err := clientset.CoreV1().Pods("mpich-system").List(metav1.ListOptions{})
// if err != nil {
// 	// handle error
// }
// for _, pod := range pods.Items {
// 	fmt.Println(pod.Name, pod.Status.PodIP)
// }
